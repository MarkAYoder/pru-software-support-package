From ee55dbc4e502ccfea2e9ad0d9697897dae496a7f Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Fri, 9 Oct 2015 16:03:30 -0500
Subject: [PATCH 6/6] rpmsg: fill in dma fields for sgs passed to virtio

The virtio_rpmsg bus allocates the vring buffers using the
dma_alloc_coherent() API, and passes them to the virtio core
using the virtqueue_add_inbuf/outbuf() API. This API takes in a
scatterlist which is prepared using the returned virtual address
from the above dma allocation API. The virtio core expects the
descriptors to be allocated from linear address space in general,
but the dma_alloc_coherent() API can return virtual addresses from
the vmalloc range if the underlying memory is allocated from a
carveout or a CMA pool in highmem.

This patch fills in the dma fields of the scatterlist structure,
and uses the newly added virtqueue_add_inbuf/outbuf_rpmsg() API
to pass these to the virtio core, so that the virtio core can
use sg_dma_address() API instead of sg_phys() API and thereby
fill in properly the physical addresses of the vring buffers in
the vring transport.

Based on a RFC patch from Edgar E. Iglesias <edgar.iglesias@xilinx.com>,
http://marc.info/?l=linux-virtualization&m=143047903512230&w=2

Suggested-by: Russell King <linux@arm.linux.org.uk>
Signed-off-by: Suman Anna <s-anna@ti.com>
---
 drivers/rpmsg/virtio_rpmsg_bus.c | 25 ++++++++++++++++++-------
 1 file changed, 18 insertions(+), 7 deletions(-)

diff --git a/drivers/rpmsg/virtio_rpmsg_bus.c b/drivers/rpmsg/virtio_rpmsg_bus.c
index 83f6469..5e416a5 100644
--- a/drivers/rpmsg/virtio_rpmsg_bus.c
+++ b/drivers/rpmsg/virtio_rpmsg_bus.c
@@ -214,6 +214,17 @@ static void __ept_release(struct kref *kref)
 	kfree(ept);
 }
 
+static inline void rpmsg_sg_init_one(struct virtproc_info *vrp,
+				     struct scatterlist *sg,
+				     void *msg, unsigned int len)
+{
+	unsigned long offset = msg - vrp->rbufs;
+
+	sg_init_table(sg, 1);
+	sg_dma_address(sg) = vrp->bufs_dma + offset;
+	sg_dma_len(sg) = len;
+}
+
 /* for more info, see below documentation of rpmsg_create_ept() */
 static struct rpmsg_endpoint *__rpmsg_create_ept(struct virtproc_info *vrp,
 		struct rpmsg_channel *rpdev, rpmsg_rx_cb_t cb,
@@ -825,12 +836,12 @@ int rpmsg_send_offchannel_raw(struct rpmsg_channel *rpdev, u32 src, u32 dst,
 			 msg, sizeof(*msg) + msg->len, true);
 #endif
 
-	sg_init_one(&sg, msg, sizeof(*msg) + len);
+	rpmsg_sg_init_one(vrp, &sg, msg, sizeof(*msg) + len);
 
 	mutex_lock(&vrp->tx_lock);
 
 	/* add message to the remote processor's virtqueue */
-	err = virtqueue_add_outbuf(vrp->svq, &sg, 1, msg, GFP_KERNEL);
+	err = virtqueue_add_outbuf_rpmsg(vrp->svq, &sg, 1, msg, GFP_KERNEL);
 	if (err) {
 		/*
 		 * need to reclaim the buffer here, otherwise it's lost
@@ -917,10 +928,10 @@ static int rpmsg_recv_single(struct virtproc_info *vrp, struct device *dev,
 		dev_warn(dev, "msg received with no recipient\n");
 
 	/* publish the real size of the buffer */
-	sg_init_one(&sg, msg, RPMSG_BUF_SIZE);
+	rpmsg_sg_init_one(vrp, &sg, msg, RPMSG_BUF_SIZE);
 
 	/* add the buffer back to the remote processor's virtqueue */
-	err = virtqueue_add_inbuf(vrp->rvq, &sg, 1, msg, GFP_KERNEL);
+	err = virtqueue_add_inbuf_rpmsg(vrp->rvq, &sg, 1, msg, GFP_KERNEL);
 	if (err < 0) {
 		dev_err(dev, "failed to add a virtqueue buffer: %d\n", err);
 		return err;
@@ -1099,10 +1110,10 @@ static int rpmsg_probe(struct virtio_device *vdev)
 		struct scatterlist sg;
 		void *cpu_addr = vrp->rbufs + i * RPMSG_BUF_SIZE;
 
-		sg_init_one(&sg, cpu_addr, RPMSG_BUF_SIZE);
+		rpmsg_sg_init_one(vrp, &sg, cpu_addr, RPMSG_BUF_SIZE);
 
-		err = virtqueue_add_inbuf(vrp->rvq, &sg, 1, cpu_addr,
-								GFP_KERNEL);
+		err = virtqueue_add_inbuf_rpmsg(vrp->rvq, &sg, 1, cpu_addr,
+						GFP_KERNEL);
 		WARN_ON(err); /* sanity check; this can't really happen */
 	}
 
-- 
1.9.1

